#include "xeus/xeus.hpp"
#include "xeus/xserver.hpp"
#include "xeus/xmessage.hpp"
#include "xeus/xkernel_configuration.hpp"
#include "xeus-lite/xserver_emscripten.hpp"
#include "xeus-lite/xembind.hpp"

#include <iostream>
#include <emscripten.h>

namespace nl = nlohmann;
namespace ems = emscripten;

namespace xeus
{
    // Get input from stdin by sending the input_request message and receiving back the
    // input_reply.  This is blocking (synchronous) from the point of view of the lite
    // kernel running in its WebWorker. The implementation in the main UI thread is async.
    //
    // It calls the globalThis.get_stdin defined in jupyterlite/xeus.
    //
    // Here implemented as a C function which is simpler than the equivalent EM_JS
    // function:
    //     EM_JS(ems::EM_VAL, get_stdin, (ems::EM_VAL input_request), {
    //         return Emval.toHandle(globalThis.get_stdin(Emval.toValue(input_request)));
    //     });
    // and the EM_JS function fails at runtime as it lacks an autogenerated signature.
    inline ems::val get_stdin(ems::val input_request)
    {
      return emscripten::val::global("self").call<ems::val>("get_stdin", input_request);
    }

    // we use this instead of EM_JS since this is more robust.
    // EM_JS functions where somewhat undefined  / buggy when
    // using them in xeus-python.
    // This might be a bit slower, but this should not be a problem
    inline void post_kernel_message(const std::string & channel, emscripten::val && message)
    {
        message.set("channel", emscripten::val(channel));
        emscripten::val::global("self").call<void>("postMessage", message); 
    } 

    xtrivial_emscripten_messenger::xtrivial_emscripten_messenger(xserver_emscripten* server)
    : p_server(server)
    {
    }

    xtrivial_emscripten_messenger::~xtrivial_emscripten_messenger()
    {
    }

    nl::json xtrivial_emscripten_messenger::send_to_shell_impl(const nl::json& message)
    {
        return p_server->notify_internal_listener(message);
    }

    xserver_emscripten::xserver_emscripten(const xconfiguration& /*config*/)
    :    p_messenger(new xtrivial_emscripten_messenger(this))
    {
    }

    xserver_emscripten::~xserver_emscripten()
    {
    }

    void xserver_emscripten::js_notify_listener(ems::val js_message)
    {
        const std::string channel = js_message["channel"].as<std::string>();
        auto message = xmessage_from_js_message(js_message);

        if(channel == "shell")
        {   
            this->notify_shell_listener(std::move(message));  
        }
        else if(channel == "control")
        {
            this->notify_control_listener(std::move(message));  
        }
        else if(channel == "stdin")
        {
            this->notify_stdin_listener(std::move(message));  
        }
        else
        {
            throw std::runtime_error("unknown channel");
        }
    }

    xcontrol_messenger& xserver_emscripten::get_control_messenger_impl() 
    {
        return *p_messenger;
    }

    void xserver_emscripten::send_shell_impl(xmessage message) 
    {
        post_kernel_message("shell", js_message_from_xmessage(message, true));
    }

    void xserver_emscripten::send_control_impl(xmessage message) 
    {
        post_kernel_message("control", js_message_from_xmessage(message, true));
    }

    void xserver_emscripten::send_stdin_impl(xmessage message) 
    {
        // Block until a response to the input request is received.
        // input_request messages are sent via get_stdin rather than post_kernel_message.
        ems::val msg = js_message_from_xmessage(message, true);
        msg.set("channel", emscripten::val("stdin"));
        ems::val js_message = get_stdin(msg);

        try
        {
            if (js_message.hasOwnProperty("error"))
            {
                std::string error_msg = js_message["error"].as<std::string>();
                throw std::runtime_error(error_msg);
            }

            auto reply = xmessage_from_js_message(js_message);
            xserver::notify_stdin_listener(std::move(reply));
        }
        catch (std::exception& e)
        {
            std::cerr << e.what() << std::endl;
        }
    }

    void xserver_emscripten::publish_impl(xpub_message message, channel) 
    {
        post_kernel_message("iopub", js_message_from_xmessage(message, true));
    }

    void xserver_emscripten::start_impl(xpub_message  /*message*/) 
    {
    }

    void xserver_emscripten::abort_queue_impl(const listener& /*l*/, long /*polling_interval*/) 
    {
    }

    void xserver_emscripten::stop_impl() 
    {
    }

    void xserver_emscripten::update_config_impl(xconfiguration& /*config*/) const 
    {
    }

    std::unique_ptr<xserver> make_xserver_emscripten(xcontext& /*context*/, const xconfiguration& config, nl::json::error_handler_t /*eh*/)
    {
        return std::make_unique<xserver_emscripten>(config);
    }
}

